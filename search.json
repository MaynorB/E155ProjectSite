[
  {
    "objectID": "ai.html",
    "href": "ai.html",
    "title": "Useage of AI",
    "section": "",
    "text": "An aspect of this project was that we had permission to utilize AI for help. We used both Gemini and ChatGPT for aid. Specifcally, it aided in helping utilize the FATFS library, helping debug it to make sure we were reading the data correctly. They were helpful in helping clear out ideas as well, making sure we were going in the general direction we wanted.\nSome aspect we realized is how interesting it made the modules for the FPGA, where AI was generally good at doing the logic you ask for, but you have to tell it basically everything on how everything works so it does it correctly. It was also interesting it avoided using peripherals at all costs except for the RAM."
  },
  {
    "objectID": "fpgaD.html",
    "href": "fpgaD.html",
    "title": "FPGA DESIGN",
    "section": "",
    "text": "RECIEVING DATA\nFirst, we will start describing the path data takes. The FPGA will read SPI data from the MCU, where it is being sent much faster than it is supposed to be played at. This is on purpose since the MCU also has to read the data and it has to do other actions like reading the DAC for the joystick values. This means we store all the data quickly in a FIFO and then the synchronizer reads it at the rate the MCU wants us to read at. The MCU produces a clock that rises every time we are supposed to play an audio sample, which in a 48kSamples/s design would mean it is 48kHz.\n\n\nFILTERS\nThis data then gets relayed to the FIR filter, which has an inbuilt RAM module to store 128 samples, then a moving average low pass filter is applied. Since an ideal FIR filter needs to “read the future”, we delay the “present” sample by 64 samples (64/48000Hz = 1.3ms) making it so the lowpass filter and this delayed unfiltered sample have no phase between them. After this we will go back to our second SPI block, which has a different chip enable to read the MCU potentiometer axis, specifically the vertical one that controls frequencies.\n\n\nMIXER\nThis data then gets relayed to a Mixer module, which takes the filtered data we just talked about, the delayed signal, and this control signal to mix the different components of audio. The way the mixer works is by first calculating a high pass filter by subtracting the low pass signal from the original signal. After this the module reconstructs the sound by adding the high pass and low pass components if you thing about it, since HighPass = Unfiltered - LowPass, HighPass + LowPass = Unfiltered. By assigning different weights to the High pass and Low pass signals, we can produce a good frequency control. It is important to notice we further amplified low frequencies before adding since they are less audible, meaning that a full low pass filter was less audible than a full high pass at the same volume level. I am not a sound engineer and just determined this based on vibes.\n\n\nPLAYING\nThis mixer data the gets relayed to the I2S module, which needs to sample the sound at a faster sampling rate to ensure no major data loss. A bit clock set to 2x16xfreq rate was used, which is in the 1-3MHz range for audio, then we have a Left_Right clock that runs at freq, and finally the data, which gets sent on the falling edge and read on the rising edge by our PCM5102 DAC is sent twice in a row since we are doing mono audio (once in the HIGH portion of LRCLK and once in the LOW).\n\n\nTESTBENCHES\nAudio SPI receiver (audio 2 bytes at a time): We can see we should get 1010-1010-1011-1011 = aabb, but it’s switched because of endianness (BYTE_SWAP = 1) \nFIFO: We can see how 1111, 2222, 3333 are sent (2 byte samples matching audio sample length) and we can get them using a different timed clock (read enable is slower than write enable) so it works for our sampling purposes. \nSynchronizer:Its in charge of reading the FIFO at the rate specified by the MCU audio playing rate pin (usually 48kHz, but can go to almost 90kHz) Here we can see how it makes the noisy data coming out of the FIFO (0000 sometimes) into a continuous stream of the desired values at the desired rate. \nTop module: Anything after the filter will not have anything since it needs 128 samples to function. This will not get simulated like this (top module). Everything else seems to work, spi reads the values (raw value is in test_val, but we have byte swap) This test val is saved faster than the 48kHz clock, but we get the data out at 48kHz, which is expected. \nI2S player: Given the following: \nWe can zoom in. We see that data changes during the falling edge of clk, which is an error that took me a while to find since I didn’t know this was necessary. Another common error was that we started sending data on the first bit when we are supposed to do it in the second bit. If we check the values (AKA 8000, 7FFF, etc…) we can see that it matches the binary representation and it has a push register way of happening.\n\n\n\nTestbench 5"
  },
  {
    "objectID": "results.html",
    "href": "results.html",
    "title": "RESULTS DESIGN",
    "section": "",
    "text": "After working in this project for over a hundred hours, we were able to get continuous playback out of the SD card while being able to skip forward to the next song, adjust the filter and speed, and be user friendly."
  },
  {
    "objectID": "mcuD.html",
    "href": "mcuD.html",
    "title": "MCU DESIGN",
    "section": "",
    "text": "We designed the MCU to be the brains of grabbing data from the SD card. Besides reading the SD card, it also reads X and Y axis values and a click from the Joystick.\n\nReading WAV\nIn order to read the .wav file, we utilize a pre-made library titled FATFS. This easily allowed us to utilize premade function to read the microSD. However, it is not a high level, rather as a mediator for us to use. To put it simply, we still had to write a few functions to properly read the microSD card. Once we were past this, we decided to utilze SPI1 to communicate with the microSD reader. When recieving data, we made a 512 byte buffer to read in chunks. The reason with this is 512 bytes is the smallest size used in MicroSDs when it comes to reading sectors. This allows us to properly extract sectors without missing data and having a faster refresh rate for ADC data.\n\n\nReading Joystick\nThe Joystick is staightforward. We decided to use an onboard Anolog Digital Connverter as our new feature in the MCU. This would make it easier to send this data to the FPGA, and allow easy value calibration that would be harder to do using system verilog. With the click, we simply used a GPIO input.\n\n\nSending Data to FPGA\nTo send these data, we have a second SPI intialized to send the buffer and joystick data. However, we ran into the problem on how the data is being sent, as it would be difficult for the FPGA to tell when it has recieved wav or joystick data. This made us use 2 different chip selects, where one controls the Audio receiving and the other controls ADC data.\n\n\nTIM2\nWe decided to use TIM2, specifcally its intrrupt to communicate with the FPGA on when the joystick data is being sent. We used a PCM value of 0 since it allows for more frequencies to be made. TIM2 controls all the dataflow of both the MCU and FPGA, where it will trigger at twice the sampling frequency to ensure we can also send a wave at the sampling frequency. We count 512 clock cycles since this corresponds to 256 samples being played, then we read and relay the SD card data, and finally we send DAC values.\n\n\nCENTERING AND CALIBRATION\nAnother issue present is that the data was not neccesarry centered, meaning that values were off when being sent causing the playback speed at the origin to not match the desired 48kSamples/s. Another issue is that a joystick can’t get max X and max y at the same time, so we added a 1.5 multiplier (sqrt(2)=1.41 is the minimum we would need for this). To correct this, we simply utilized a function made to clamp the max value read from the joystick on either axis, allowing us to monimize bugds."
  },
  {
    "objectID": "reference.html",
    "href": "reference.html",
    "title": "References and Acknowledgements",
    "section": "",
    "text": "HMC E155 Course Site\nSTM32L432KC Datasheet\nSTM32L4 Reference Manual\nFatFs Documentation\nICE40 RAM"
  },
  {
    "objectID": "reference.html#references",
    "href": "reference.html#references",
    "title": "References and Acknowledgements",
    "section": "",
    "text": "HMC E155 Course Site\nSTM32L432KC Datasheet\nSTM32L4 Reference Manual\nFatFs Documentation\nICE40 RAM"
  },
  {
    "objectID": "reference.html#acknowledgements",
    "href": "reference.html#acknowledgements",
    "title": "References and Acknowledgements",
    "section": "Acknowledgements",
    "text": "Acknowledgements\nWe would like to thank all other students in the lab who helped us find issues and debug some of our code.\nWe would like to acknowledge Prof. Spencer for not only teaching the class but for helping us with any question we had, big or small. Providing aid when we need it and giving us advice on how to approch our project."
  },
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "E155 Project",
    "section": "",
    "text": "We are Carlos and Maynor, both Junior Mudders. For our E155 project, we decided to make a portable DJ set. Using the MCU and FPGA, we were able to apply a high or low pass filter, plus either speed up or slow down the song playing. With a click of the joystick, you can also skip the current song playing to the next one, looping through 16 songs."
  },
  {
    "objectID": "bill.html",
    "href": "bill.html",
    "title": "Documentation Of our Project",
    "section": "",
    "text": "Below is a table of the parts we used. Those with astricks are new hardware we used. While most of these are simple, specifcally the MicroSD reader and DAC module are new as we have not used either one of these. The MicroSD card introduces a new library while the DAC module brings a new type of logic that has been breifly covered.\n\n\n\nPart Name\nPart Number / Model\nLink\nNotes\n\n\n\n\nMicroSD Card Reader *\nAdafruit 254\nDigiKey\nStandard breakout board/Stockroom\n\n\n16GB microSD Card *\nSanDisk SDSQUNC-016G-AN6MA\nSanDisk Store\nClass 10 UHS-I/Stockroom\n\n\nJoystick Module *\nSunFounder ST0001\nDigiKey\nXY analog joystick/Stockroom\n\n\nDAC Module *\nTeyleten Robot PCM5102A DAC\nAmazon\nI2S DAC — for audio output from FPGA/MCU/$13.88\n\n\nNucleo-L432KC\nNUCLEO-L432KC\n(add link)\nMain MCU/Lab Kit\n\n\nUpduino FPGA Board\nUPDuino v3.1\n(add link)\nICE40UP5K FPGA board/Lab Kit"
  },
  {
    "objectID": "bill.html#parts-list",
    "href": "bill.html#parts-list",
    "title": "Documentation Of our Project",
    "section": "",
    "text": "Below is a table of the parts we used. Those with astricks are new hardware we used. While most of these are simple, specifcally the MicroSD reader and DAC module are new as we have not used either one of these. The MicroSD card introduces a new library while the DAC module brings a new type of logic that has been breifly covered.\n\n\n\nPart Name\nPart Number / Model\nLink\nNotes\n\n\n\n\nMicroSD Card Reader *\nAdafruit 254\nDigiKey\nStandard breakout board/Stockroom\n\n\n16GB microSD Card *\nSanDisk SDSQUNC-016G-AN6MA\nSanDisk Store\nClass 10 UHS-I/Stockroom\n\n\nJoystick Module *\nSunFounder ST0001\nDigiKey\nXY analog joystick/Stockroom\n\n\nDAC Module *\nTeyleten Robot PCM5102A DAC\nAmazon\nI2S DAC — for audio output from FPGA/MCU/$13.88\n\n\nNucleo-L432KC\nNUCLEO-L432KC\n(add link)\nMain MCU/Lab Kit\n\n\nUpduino FPGA Board\nUPDuino v3.1\n(add link)\nICE40UP5K FPGA board/Lab Kit"
  },
  {
    "objectID": "bill.html#new-hardware",
    "href": "bill.html#new-hardware",
    "title": "Documentation Of our Project",
    "section": "NEW HARDWARE",
    "text": "NEW HARDWARE\nThe new hardware we added to this project was the SD card reader, the joystick, and the DAC. The SD card reader is used to read music we save, the joystick to control the sound output and the DAC to play the sound."
  },
  {
    "objectID": "bill.html#schematic",
    "href": "bill.html#schematic",
    "title": "Documentation Of our Project",
    "section": "Schematic",
    "text": "Schematic\nIn the following diagram, it is our electircal schmeatic on how we wired up our hardware. Note that our joystick we have reversed ground and 3.3V due to the signal sending the joystick click being wired to ground for an unknown reason. This did not affect the functionality of the joystick since it works based on resistances."
  },
  {
    "objectID": "bill.html#block-diragram",
    "href": "bill.html#block-diragram",
    "title": "Documentation Of our Project",
    "section": "Block Diragram",
    "text": "Block Diragram\nThe following diagrams are associated with our FPGA. The first diagram showcases our block modules used in digitalk logic in the whole system. The second diagram was generated by Radiant to describe the functionality of the FPGA itself."
  }
]