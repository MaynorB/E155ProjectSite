---
title: "FPGA DESIGN"
about:
    template: jolla
---

# RECIEVING DATA
First, we will start describing the path data takes. The FPGA will read SPI data from the MCU, where it is being sent much faster than it is supposed to be played at. This is on purpose since the MCU also has to read the data and it has to do other actions like reading the DAC for the joystick values. This means we store all the data quickly in a FIFO and then the synchronizer reads it at the rate the MCU wants us to read at. The MCU produces a clock that rises every time we are supposed to play an audio sample, which in a 48kSamples/s design would mean it is 48kHz. 

# FILTERS
This data then gets relayed to the FIR filter, which has an inbuilt RAM module to store 128 samples, then a moving average low pass filter is applied. Since an ideal FIR filter needs to "read the future", we delay the "present" sample by 64 samples (64/48000Hz = 1.3ms) making it so the lowpass filter and this delayed unfiltered sample have no phase between them. After this we will go back to our second SPI block, which has a different chip enable to read the MCU potentiometer axis, specifically the vertical one that controls frequencies. 



# MIXER
This data then gets relayed to a Mixer module, which takes the filtered data we just talked about, the delayed signal, and this control signal to mix the different components of audio. The way the mixer works is by first calculating a high pass filter by subtracting the low pass signal from the original signal. After this the module reconstructs the sound by adding the high pass and low pass components if you thing about it, since HighPass = Unfiltered - LowPass, HighPass + LowPass = Unfiltered. By assigning different weights to the High pass and Low pass signals, we can produce a good frequency control. It is important to notice we further amplified low frequencies before adding since they are less audible, meaning that a full low pass filter was less audible than a full high pass at the same volume level. I am not a sound engineer and just determined this based on vibes. 

# PLAYING
This mixer data the gets relayed to the I2S module, which needs to sample the sound at a faster sampling rate to ensure no major data loss. A bit clock set to 2x16xfreq rate was used, which is in the 1-3MHz range for audio, then we have a Left_Right clock that runs at freq, and finally the data, which gets sent on the falling edge and read on the rising edge by our PCM5102 DAC is sent twice in a row since we are doing mono audio (once in the HIGH portion of LRCLK and once in the LOW). 

# TESTBENCHES 

### Audio SPI receiver (audio 2 bytes at a time): 
We can see we should get 1010-1010-1011-1011 = aabb, but it's switched because of endianness (BYTE_SWAP = 1)
![Testbench 1](images/testbench1.png)


### FIFO:
    We can see how 1111, 2222, 3333 are sent (2 byte samples matching audio sample length) and we can get them using a different timed clock (read enable is slower than write enable) so it works for our sampling purposes.
![Testbench 2](images/testbench2.png)

### Synchronizer:
    Its in charge of reading the FIFO at the rate specified by the MCU audio playing rate pin (usually 48kHz, but can go to almost 90kHz) Here we can see how it makes the noisy data coming out of the FIFO (0000 sometimes) into a continuous stream of the desired values at the desired rate.
![Testbench 3](images/testbench3.png)

### Top module:
    Anything after the filter will not have anything since it needs 128 samples to function. This will not get simulated like this (top module). Everything else seems to work, spi reads the values (raw value is in test_val, but we have byte swap) This test val is saved faster than the 48kHz clock, but we get the data out at 48kHz, which is expected. 
![Testbench 4](images/testbench4.png)

### I2S player:
    Given the following:
![Testbench 4.2](images/testbench43.png)
We can zoom in. We see that data changes during the falling edge of clk, which is an error that took me a while to find since I didn’t know this was necessary. Another common error was that we started sending data on the first bit when we are supposed to do it in the second bit. If we check the values (AKA 8000, 7FFF, etc…) we can see that it matches the binary representation and it is similar to SPI where a clock tells the suystem when to save data. 
![Testbench 4.5](images/testbench45.png)


### FIR Filter {#fir-filter}
![Testbench 5](images/testbench5.png)