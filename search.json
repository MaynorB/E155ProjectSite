[
  {
    "objectID": "ai.html",
    "href": "ai.html",
    "title": "Useage of AI",
    "section": "",
    "text": "An aspect of this project was that we had permission to utilize AI for help. We used both Gemini and ChatGPT for aid. Specifcally, it aided in helping utilize the FATFS library, helping debug it to make sure we were reading the data correctly. They were helpful in helping clear out ideas as well, making sure we were going in the general direction we wanted.\nSome aspect we realized is how interesting it made the modules for the FPGA, where AI was generally good at doing the logic you ask for, but you have to tell it basically everything on how everything works so it does it correctly. It was also interesting it avoided using peripherals at all costs except for the RAM."
  },
  {
    "objectID": "fpgaD.html",
    "href": "fpgaD.html",
    "title": "FPGA DESIGN",
    "section": "",
    "text": "RECEIVING DATA\nFirst, we start by describing the path data takes. The FPGA will read SPI data from the MCU, where it is sent much faster than it is supposed to be played. This is intentional: the MCU also has to read the data and perform other actions like reading the DAC for the joystick values. This means we store all the data quickly in a FIFO, and then the synchronizer reads it at the rate the MCU wants us to read at. The MCU produces a clock that rises every time we are supposed to play an audio sample, which in a 48 kSamples/s design means 48 kHz.\n\n\nFILTERS\nThis data then gets relayed to the FIR filter, which has an inbuilt RAM module to store 128 samples. A moving average low-pass filter is then applied. Since an ideal FIR filter needs to “read the future,” we delay the “present” sample by 64 samples:\n\\[\n\\frac{64}{48{,}000} = 1.3\\text{ ms}\n\\]\nThis makes the low‑pass output and the delayed unfiltered signal phase‑aligned. After this, we go back to our second SPI block, which has a different chip‑enable to read the MCU potentiometer axis, specifically the vertical one that controls frequencies.\nSee the FIR Filter Testbench here!\n\n\nMIXER\nThis data then gets relayed to a Mixer module, which takes the filtered data, the delayed signal, and the control signal to mix different audio components.\nThe mixer works by computing a high‑pass component:\n\\[\n\\text{HighPass} = \\text{Unfiltered} - \\text{LowPass}\n\\]\nThen reconstructing the sound:\n\\[\n\\text{HighPass} + \\text{LowPass} = \\text{Unfiltered}\n\\]\nBy assigning different weights to the high‑pass and low‑pass signals, we can produce frequency control. Low frequencies are further amplified since they are less audible; this makes the filter sound more balanced.\n\n\nPLAYING\nThe mixer output is relayed to the I2S module, which needs to sample the sound at a higher sampling rate to avoid data loss. A bit clock set to (2 f_{}) is used (1–3 MHz range). The left/right clock runs at the sample frequency, and the data line sends each mono sample twice—once during the HIGH portion of LRCLK and once during the LOW portion.\n\n\nTESTBENCHES\n\nAudio SPI Receiver (audio 2 bytes at a time)\nWe expect to get 1010-1010-1011-1011 = aabb, but it is swapped due to endianness (BYTE_SWAP = 1).\n\n\n\nFIFO\nWe can see how 1111, 2222, and 3333 are sent (2‑byte samples matching audio sample length) and retrieved using a differently timed clock (read enable is slower than write enable).\n\n\n\nSynchronizer\nThe synchronizer reads the FIFO at the MCU‑specified rate (usually 48 kHz, up to ~90 kHz). It converts occasionally noisy FIFO output (like 0000) into a continuous, correctly‑timed stream.\n\n\n\nTop Module\nAnything after the filter will not show data, since it needs 128 samples to function. Everything else operates correctly: SPI reads values into test_val (after byte swap). Data is saved faster than the 48 kHz clock but output at 48 kHz, as intended.\n\n\n\nI2S Player\nGiven the following:\n\nZooming in, we see that data changes during the falling edge of the clock, which is incorrect—data must change on falling and be read on rising by the PCM5102. Another common mistake was starting transmission on the first bit instead of the second.\nChecking sample values (8000, 7FFF, etc.), we confirm they match their binary representation.\n\n\n\nFIR Filter"
  },
  {
    "objectID": "results.html",
    "href": "results.html",
    "title": "RESULTS DESIGN",
    "section": "",
    "text": "After working in this project for over a hundred hours, we were able to get continuous playback out of the SD card while being able to skip forward to the next song, adjust the filter and speed, and be user friendly."
  },
  {
    "objectID": "results.html#formulas-for-performance",
    "href": "results.html#formulas-for-performance",
    "title": "RESULTS DESIGN",
    "section": "Formulas for Performance",
    "text": "Formulas for Performance\nUsing a Moving Average filter as the lowpass filter was probably not an ideal choice, but its simplicity and results were good. This filter should have a “corner frequency” of around 165 Hz, done with the formula:\n\\[\n\\frac{48{,}000 \\times 0.441}{128} = 165.4\\ \\text{Hz}\n\\]\nAnother consideration is the maximun and minimum playing speeds, in our case, we chose to use the following value, where the ADC value goes from 0 - 255; \n\\[\n455 + 772 = 1217\n\\] This means we have a frequency of \\[\n80,000,000/(1218) = 65681Hz\n\\] which means our playback speed is 32840Hz, or 68.4% of the original sampling rate. Using the minimum ARR of 455, we get a playing speed of; \\[\n80,000,000/(455) = 175824Hz\n\\] which means our playback speed is 87912Hz, or 183.2% of the original sampling rate.\nGoing faster than this showed issues because of how fast SPI transfers data, which could be optimized, but audio at 183% playback speed is already really high pitch.\nThe FIR filter chosen should have the following frequency response:\n\n\n\nalt"
  },
  {
    "objectID": "mcuD.html",
    "href": "mcuD.html",
    "title": "MCU DESIGN",
    "section": "",
    "text": "We designed the MCU to be the brains of grabbing data from the SD card. Besides reading the SD card, it also reads X and Y axis values and a click from the Joystick.\n\nReading WAV\nIn order to read the .wav file, we utilize a pre-made library titled FATFS. This easily allowed us to utilize premade function to read the microSD. However, it is not a high level, rather as a mediator for us to use. To put it simply, we still had to write a few functions to properly read the microSD card. Once we were past this, we decided to utilze SPI1 to communicate with the microSD reader. When recieving data, we made a 512 byte buffer to read in chunks. The reason with this is 512 bytes is the smallest size used in MicroSDs when it comes to reading sectors. This allows us to properly extract sectors without missing data and having a faster refresh rate for ADC data.\n\n\nReading Joystick\nThe Joystick is staightforward. We decided to use an onboard Anolog Digital Connverter as our new feature in the MCU. This would make it easier to send this data to the FPGA, and allow easy value calibration that would be harder to do using system verilog. With the click, we simply used a GPIO input.\n\n\nSending Data to FPGA\nTo send these data, we have a second SPI intialized to send the buffer and joystick data. However, we ran into the problem on how the data is being sent, as it would be difficult for the FPGA to tell when it has recieved wav or joystick data. This made us use 2 different chip selects, where one controls the Audio receiving and the other controls ADC data.\n\n\nTIM2\nWe decided to use TIM2, specifcally its intrrupt to communicate with the FPGA on when the joystick data is being sent. We used a PCM value of 0 since it allows for more frequencies to be made. TIM2 controls all the dataflow of both the MCU and FPGA, where it will trigger at twice the sampling frequency to ensure we can also send a wave at the sampling frequency. We count 512 clock cycles since this corresponds to 256 samples being played, then we read and relay the SD card data, and finally we send DAC values.\n\n\nCENTERING AND CALIBRATION\nAnother issue present is that the data was not neccesarry centered, meaning that values were off when being sent causing the playback speed at the origin to not match the desired 48kSamples/s. Another issue is that a joystick can’t get max X and max y at the same time, so we added a 1.5 multiplier (sqrt(2)=1.41 is the minimum we would need for this). To correct this, we simply utilized a function made to clamp the max value read from the joystick on either axis, allowing us to monimize bugds."
  },
  {
    "objectID": "reference.html",
    "href": "reference.html",
    "title": "References and Acknowledgements",
    "section": "",
    "text": "HMC E155 Course Site\nSTM32L432KC Datasheet\nSTM32L4 Reference Manual\nFatFs Documentation\nICE40 RAM"
  },
  {
    "objectID": "reference.html#references",
    "href": "reference.html#references",
    "title": "References and Acknowledgements",
    "section": "",
    "text": "HMC E155 Course Site\nSTM32L432KC Datasheet\nSTM32L4 Reference Manual\nFatFs Documentation\nICE40 RAM"
  },
  {
    "objectID": "reference.html#acknowledgements",
    "href": "reference.html#acknowledgements",
    "title": "References and Acknowledgements",
    "section": "Acknowledgements",
    "text": "Acknowledgements\nWe would like to thank all other students in the lab who helped us find issues and debug some of our code.\nWe would like to acknowledge Prof. Spencer for not only teaching the class but for helping us with any question we had, big or small. Providing aid when we need it and giving us advice on how to approch our project."
  },
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "PORTABLE DJ SET",
    "section": "",
    "text": "We are Carlos (ENGINEERING) and Maynor (COMPUTER SCIENCE), both Junior Mudders. For our E155 project, we decided to make a portable DJ set. Using the MCU and FPGA, we were able to apply a high or low pass filter, plus either speed up or slow down the song playing. With a click of the joystick, you can also skip the current song playing to the next one, looping through 16 songs."
  },
  {
    "objectID": "bill.html",
    "href": "bill.html",
    "title": "Documentation Of our Project",
    "section": "",
    "text": "Below is a table of the parts we used. Those with astricks are new hardware we used. While most of these are simple, specifcally the MicroSD reader and DAC module are new as we have not used either one of these. The MicroSD card introduces a new library while the DAC module brings a new type of logic that has been breifly covered.\n\n\n\nPart Name\nPart Number / Model\nLink\nNotes\n\n\n\n\nMicroSD Card Reader *\nAdafruit 254\nDigiKey\nStandard breakout board/Stockroom\n\n\n16GB microSD Card *\nSanDisk SDSQUNC-016G-AN6MA\nSanDisk Store\nClass 10 UHS-I/Stockroom\n\n\nJoystick Module *\nSunFounder ST0001\nDigiKey\nXY analog joystick/Stockroom\n\n\nDAC Module *\nTeyleten Robot PCM5102A DAC\nAmazon\nI2S DAC — for audio output from FPGA/MCU/$13.88\n\n\nNucleo-L432KC\nNUCLEO-L432KC\n(add link)\nMain MCU/Lab Kit\n\n\nUpduino FPGA Board\nUPDuino v3.1\n(add link)\nICE40UP5K FPGA board/Lab Kit"
  },
  {
    "objectID": "bill.html#parts-list",
    "href": "bill.html#parts-list",
    "title": "Documentation Of our Project",
    "section": "",
    "text": "Below is a table of the parts we used. Those with astricks are new hardware we used. While most of these are simple, specifcally the MicroSD reader and DAC module are new as we have not used either one of these. The MicroSD card introduces a new library while the DAC module brings a new type of logic that has been breifly covered.\n\n\n\nPart Name\nPart Number / Model\nLink\nNotes\n\n\n\n\nMicroSD Card Reader *\nAdafruit 254\nDigiKey\nStandard breakout board/Stockroom\n\n\n16GB microSD Card *\nSanDisk SDSQUNC-016G-AN6MA\nSanDisk Store\nClass 10 UHS-I/Stockroom\n\n\nJoystick Module *\nSunFounder ST0001\nDigiKey\nXY analog joystick/Stockroom\n\n\nDAC Module *\nTeyleten Robot PCM5102A DAC\nAmazon\nI2S DAC — for audio output from FPGA/MCU/$13.88\n\n\nNucleo-L432KC\nNUCLEO-L432KC\n(add link)\nMain MCU/Lab Kit\n\n\nUpduino FPGA Board\nUPDuino v3.1\n(add link)\nICE40UP5K FPGA board/Lab Kit"
  },
  {
    "objectID": "bill.html#new-hardware",
    "href": "bill.html#new-hardware",
    "title": "Documentation Of our Project",
    "section": "NEW HARDWARE",
    "text": "NEW HARDWARE\nThe new hardware we added to this project was the SD card reader, the joystick, and the DAC. The SD card reader is used to read music we save, the joystick to control the sound output and the DAC to play the sound."
  },
  {
    "objectID": "bill.html#schematic",
    "href": "bill.html#schematic",
    "title": "Documentation Of our Project",
    "section": "Schematic",
    "text": "Schematic\nIn the following diagram, it is our electircal schmeatic on how we wired up our hardware. Note that our joystick we have reversed ground and 3.3V due to the signal sending the joystick click being wired to ground for an unknown reason. This did not affect the functionality of the joystick since it works based on resistances."
  },
  {
    "objectID": "bill.html#block-diragram",
    "href": "bill.html#block-diragram",
    "title": "Documentation Of our Project",
    "section": "Block Diragram",
    "text": "Block Diragram\nThe following diagrams are associated with our FPGA. The first diagram showcases our block modules used in digitalk logic in the whole system. The second diagram was generated by Radiant to describe the functionality of the FPGA itself."
  }
]